////////////////////////////////////////////////////////////////////
//
//  Load all data 
//
////////////////////////////////////////////////////////////////////


//Sub-Saharan Africa administrative district shapefile
var SSA = ee.FeatureCollection('users/salem043/Africa_Districts');

//Ecoregions data
var ecodata = ee.FeatureCollection('RESOLVE/ECOREGIONS/2017');

//Camp data
var camps = ee.FeatureCollection('users/salem043/allcampwide');
//Map.addLayer(camps);


var campFilter = ee.Filter.inList('country', ['Senegal', 'Gambia',
'Guinea-Bissau', 'Guinea', 'Sierra Leone', 'Liberia', 'Ivory Coast', 'Mali',
'Burkina Faso', 'Ghana',
'Togo', 'Benin', 'Niger', 'Nigeria']);
var campRegion = camps.filter(campFilter);




//Produce 30 km  buffer around the camps - this the are we are going to study
var bufferPoly = function(feature) {
  return feature.buffer(30000);  //!!Change back to 50k after making sure the border identification works 
};

var buffers = campRegion.map(bufferPoly);

var buffsUnion = buffers.union();

//dissolve and transform to FC so that we can identify each
//tile's buffer ID

var buffsGeoDissolve =buffers.geometry().dissolve();
//print(buffsGeoDissolve, "Dissolve using geometry().dissolve()"); //Multipolygon!
Map.addLayer(buffsGeoDissolve, {}, 'Dissolve using geometry().dissolve()');


var fc = ee.FeatureCollection([
  ee.Feature(buffsGeoDissolve)
]);
//print(fc);

var multiGeomExplodeList = fc.toList(fc.size()).map(function(feature) {
  var geomList = ee.Feature(feature).geometry().geometries();
  var featureList = geomList.map(function(geom) {
    return ee.Feature(ee.Geometry(geom));
  });
  return featureList;
})
.flatten();

var buffDissolveFC = ee.FeatureCollection(multiGeomExplodeList);

//ESA stack of images
var lulc = ee.Image('users/salem043/ESA_1992_2015').clip(buffsUnion);
//print(lulc, "Land cover data global raw");

//Subset and name bands for clarity
var lulcYrSub = lulc.select(['b9', 'b10', 'b11', 'b12', 'b13', 
'b14', 'b15', 'b16', 'b17', 'b18', 'b19', 'b20', 'b21'], ["lc_2000", "lc_2001", 
'lc_2002', 'lc_2003', 'lc_2004', 'lc_2005', 'lc_2006', 'lc_2007', 'lc_2008',
'lc_2009', 'lc_2010', 'lc_2011', 'lc_2012']);
print(lulcYrSub);


////////////////////////////////////////////////////////////////////
//
//  Generate tiles to correspond with other data
//
////////////////////////////////////////////////////////////////////

var tiles = tile(buffDissolveFC , 0.1); //Change to 0.02 when done 

function tile(region, size_in_degrees) {
  function tile_geometry(geometry) {
    var coords = ee.List(geometry.bounds().coordinates().get(0))
    var min_point = ee.List(coords.get(0))
    var max_point = ee.List(coords.get(2))
  
    function sequence(direction) {
      var start = min_point.get(direction)  
      var stop = ee.Number(max_point.get(direction))
      return ee.List.sequence(start, stop, size_in_degrees)
    }
  
    var tiles = sequence(0).map(function (x) {
      return sequence(1).map(function (y) { 
          return ee.Feature(ee.Geometry.Rectangle([
            [ee.Number(x), ee.Number(y)],
            [
              ee.Number(x).add(size_in_degrees).min(max_point.get(0)),
              ee.Number(y).add(size_in_degrees).min(max_point.get(1))
            ]
        ]).intersection(geometry, 30))
      })
  	}).flatten()
    return ee.FeatureCollection(tiles).filterBounds(geometry)
  }

  function tile_feature_collection(feature_collection) {
    return ee.FeatureCollection(
      feature_collection.iterate(
        function (feature, acc) {
          return ee.FeatureCollection(acc).merge(tile_geometry(ee.Feature(feature).geometry()))
        }, ee.FeatureCollection([]))
    )
  }

  if (region instanceof ee.FeatureCollection)
    return tile_feature_collection(region)
  else if (region instanceof ee.Feature)
    return tile_geometry(region.geometry())
  else if (region instanceof ee.Geometry)
    return tile_geometry(region)
  else
    throw Error(
      'region must be ee.FeatureCollection, ee.Feature, or ee.Geometry. Was ' + region
    )
}

//print(tiles.limit(10), "Baseline tiles");





////////////////////////////////////////////////////////////////////
//
//  Calculate number of pixels in each tile that have different
//  properties (ex: water, settlement, etc.)
//
////////////////////////////////////////////////////////////////////

// lulc types we want to obtain counts for
var indices = ee.List([0, 10, 11, 12, 20, 30, 40, 50, 60, 61, 62, 70, 71, 72, 80,
81, 82, 90, 100, 110, 120, 121, 122, 130, 140, 150, 152, 153, 160, 170, 180, 190,
200, 201, 202, 210, 220]);


var lulc_2000 = lulcYrSub.select(["lc_2000"]);

var tiles_2000 = tiles.map(function(feature){
  var mdata = indices.iterate(function(i, dictin){
    var thisLC = i ;
    var bandname = ee.String('lulc_2000_').cat(ee.Number(thisLC).int());
    var lulc_thisLC = lulc_2000.remap([i], [1], null);
    var dict = lulc_thisLC.rename(bandname)
      .reduceRegion({reducer:'count', geometry: feature.geometry(), scale: 100});
    return ee.Dictionary(dictin).combine(dict);
  }, ee.Dictionary()) ;
  return feature.set(mdata);
});


var lulc_2001 = lulcYrSub.select(["lc_2001"]);

var tiles_2001 = tiles_2000.map(function(feature){
  var mdata = indices.iterate(function(i, dictin){
    var thisLC = i ;
    var bandname = ee.String('lulc_2001_').cat(ee.Number(thisLC).int());
    var lulc_thisLC = lulc_2001.remap([i], [1], null);
    var dict = lulc_thisLC.rename(bandname)
      .reduceRegion({reducer:'count', geometry: feature.geometry(), scale: 100});
    return ee.Dictionary(dictin).combine(dict);
  }, ee.Dictionary()) ;
  return feature.set(mdata);
});

print(tiles_2001.limit(3), "Tile results");


var lulc_2002 = lulcYrSub.select(["lc_2002"]);

var tiles_2002 = tiles_2001.map(function(feature){
  var mdata = indices.iterate(function(i, dictin){
    var thisLC = i ;
    var bandname = ee.String('lulc_2002_').cat(ee.Number(thisLC).int());
    var lulc_thisLC = lulc_2002.remap([i], [1], null);
    var dict = lulc_thisLC.rename(bandname)
      .reduceRegion({reducer:'count', geometry: feature.geometry(), scale: 100});
    return ee.Dictionary(dictin).combine(dict);
  }, ee.Dictionary()) ;
  return feature.set(mdata);
});

print(tiles_2002.limit(3), "Tile results");


var lulc_2003 = lulcYrSub.select(["lc_2003"]);

var tiles_2003 = tiles_2002.map(function(feature){
  var mdata = indices.iterate(function(i, dictin){
    var thisLC = i ;
    var bandname = ee.String('lulc_2003_').cat(ee.Number(thisLC).int());
    var lulc_thisLC = lulc_2003.remap([i], [1], null);
    var dict = lulc_thisLC.rename(bandname)
      .reduceRegion({reducer:'count', geometry: feature.geometry(), scale: 100});
    return ee.Dictionary(dictin).combine(dict);
  }, ee.Dictionary()) ;
  return feature.set(mdata);
});


var lulc_2004 = lulcYrSub.select(["lc_2004"]);

var tiles_2004 = tiles_2003.map(function(feature){
  var mdata = indices.iterate(function(i, dictin){
    var thisLC = i ;
    var bandname = ee.String('lulc_2004_').cat(ee.Number(thisLC).int());
    var lulc_thisLC = lulc_2004.remap([i], [1], null);
    var dict = lulc_thisLC.rename(bandname)
      .reduceRegion({reducer:'count', geometry: feature.geometry(), scale: 100});
    return ee.Dictionary(dictin).combine(dict);
  }, ee.Dictionary()) ;
  return feature.set(mdata);
});


var lulc_2005 = lulcYrSub.select(["lc_2005"]);

var tiles_2005 = tiles_2004.map(function(feature){
  var mdata = indices.iterate(function(i, dictin){
    var thisLC = i ;
    var bandname = ee.String('lulc_2005_').cat(ee.Number(thisLC).int());
    var lulc_thisLC = lulc_2005.remap([i], [1], null);
    var dict = lulc_thisLC.rename(bandname)
      .reduceRegion({reducer:'count', geometry: feature.geometry(), scale: 100});
    return ee.Dictionary(dictin).combine(dict);
  }, ee.Dictionary()) ;
  return feature.set(mdata);
});



