///////////////////////////////////////////////////////////////////////
//
//  Initial data prep
//
///////////////////////////////////////////////////////////////////////

//Read in camp data - this is saved in wide format, with binary indicators
//of whether a camp was open 1999-2016
var camps = ee.FeatureCollection('users/salem043/allcampwide');

//Produce 50 km  buffer around the camps - this the are we are going to study
var bufferPoly = function(feature) {
  return feature.buffer(50000);   
};

var buffers = camps.map(bufferPoly);
//Map.addLayer(buffers, {color: 'yellow'}, 'buffers');


//For training, select one of these buffers 
//!!!Drop this when producing full sample
var buffsSample=buffers.limit(1);
//Map.addLayer(buffsSample);
Map.centerObject(buffsSample);


//Produce a 1 km buffer around the camp: this is the camp area, we want
//to drop any tiles that interesct this buffer
var bufferPoly2 = function(feature) {
  return feature.buffer(1000);   
};

var campArea = camps.map(bufferPoly2);
//Map.addLayer(campArea, {color: 'cyan'}, 'camp area');
//Map.addLayer(camps, {color: 'red'}, 'camps');


//Import Hansen Global Forest Change data
var gfc2014 = ee.Image('UMD/hansen/global_forest_change_2015');

//Clip GFC down to the subsample buffer
//!!Change this when upscaling
var gfcSample = gfc2014.clip(buffsSample);
print(gfcSample, "GFC geographic subsample")

//The bands we rely on for our analysis
var gfcSampleCover2000= gfcSample.select(["treecover2000"]);
var gfcSampleMask=gfcSample.select(["datamask"])
var gfcSampleLossYr = gfcSample.select(["lossyear"])


///////////////////////////////////////////////////////////////////////
//
//  Clean the GFC data - use the mask layer to assign all pixels
//  with no data or in bodies of water as NA
//
///////////////////////////////////////////////////////////////////////

//Reclassify 2 = NA and 0 = NA in the mask layer

var gfcSampleMask = gfcSampleMask
.remap([ 1],
       [1], null);
       
//Map.addLayer(gfcSampleMask);

//Mask the mask layer to the two other GEE rasters so that NAs in the
//mask layer are NAs in those rasters
//var gfcSampleCover2000Masked=mask()

var gfc2000CoverMasked = gfcSampleCover2000.updateMask(gfcSampleMask);
//Map.addLayer(gfc2000CoverMasked);

var gfcLossYearMasked  = gfcSampleLossYr.updateMask(gfcSampleMask);
//Map.addLayer(gfcLossYearMasked);

///////////////////////////////////////////////////////////////////////
//
//  Tile production - we'll use these tiles to calculate zonal stats.
//  The tiles are the unit of analysis in our regression
//
///////////////////////////////////////////////////////////////////////

//Tiles below are measured in degrees. (Ugh, but I want meters!)
//0.1 degrees is about 11 km at equator. Kept large for training
//Code courtesty of a kind stranger who offered it on Stack Exchange
//!!Need to figure out how to form these tiles in meters
//!!Downscale tiles to finer resolution when scaling up (0.01, about 1 km)
var tiles = tile(buffsSample, 0.1);

function tile(region, size_in_degrees) {
  function tile_geometry(geometry) {
    var coords = ee.List(geometry.bounds().coordinates().get(0))
    var min_point = ee.List(coords.get(0))
    var max_point = ee.List(coords.get(2))
  
    function sequence(direction) {
      var start = min_point.get(direction)
      var stop = ee.Number(max_point.get(direction))
      return ee.List.sequence(start, stop, size_in_degrees)
    }
  
    var tiles = sequence(0).map(function (x) {
      return sequence(1).map(function (y) { 
          return ee.Feature(ee.Geometry.Rectangle([
            [ee.Number(x), ee.Number(y)],
            [
              ee.Number(x).add(size_in_degrees).min(max_point.get(0)),
              ee.Number(y).add(size_in_degrees).min(max_point.get(1))
            ]
        ]).intersection(geometry, 30))
      })
  	}).flatten()
    return ee.FeatureCollection(tiles).filterBounds(geometry)
  }

  function tile_feature_collection(feature_collection) {
    return ee.FeatureCollection(
      feature_collection.iterate(
        function (feature, acc) {
          return ee.FeatureCollection(acc).merge(tile_geometry(ee.Feature(feature).geometry()))
        }, ee.FeatureCollection([]))
    )
  }

  if (region instanceof ee.FeatureCollection)
    return tile_feature_collection(region)
  else if (region instanceof ee.Feature)
    return tile_geometry(region.geometry())
  else if (region instanceof ee.Geometry)
    return tile_geometry(region)
  else
    throw Error(
      'region must be ee.FeatureCollection, ee.Feature, or ee.Geometry. Was ' + region
    )
}

print(tiles, "Tile example");

Map.addLayer(tiles);


///////////////////////////////////////////////////////////////////////
//
//  Zonal statistics from GFC: includes
//    1. Number of non-NA GFC pixels in each tile
//    2. GFC Mean pct. forest cover in 200 for each tile
//    3. Number of pixels with zero FC in 2000
//    4. Number of pixels that transition to zero FC each year (01-12)
//
///////////////////////////////////////////////////////////////////////


//1. Number of pixels in each tile

//Select one layer of GFC 
var gfc2000Sample=gfcSample.select(['treecover2000']);
Map.addLayer(gfc2000Sample);


var pixelCounts = tiles.map(function(feature) {
  return feature.set(gfc2000CoverMasked.reduceRegion({
    reducer: 'count',
    geometry: feature.geometry(),
    scale: 100,
  }));
});

var tileCounts = pixelCounts.select(
    ['treecover2000'], ['number_pixels']            
);

print("Number of pixels that are not NA", tileCounts);


//2. Mean pct forest cover of tile in 2000

var tileCountsPlusBaseline = tileCounts.map(function(feature) {
  return feature.set(gfc2000CoverMasked.reduceRegion({
    reducer: 'mean',
    geometry: feature.geometry(),
    scale: 100,
  }));
});

print("Updated FC", tileCountsPlusBaseline);



//2. Number of pixels with zero FC in 2000

var gfc2000CoverZeroes = gfc2000CoverMasked
.remap([ 0], [1], null);

print(gfc2000CoverZeroes, "2000 pixels with zero FC");
Map.addLayer(gfc2000CoverZeroes);


var TileCounts2 = tileCountsPlusBaseline.map(function(feature) {
  return feature.set(gfc2000CoverZeroes.reduceRegion({
    reducer: 'count',
    geometry: feature.geometry(),
    scale: 100,
  }));
});

print(TileCounts2);

var DataRenamed = Data.map(function(feat){
  return ee.Feature(feat.geometry(), { 
    numPixelsNoNA: feat.get('number_pixels')
  })
})
print(DataRenamed, "renaming");

var tileCounts3 = TileCounts2.select(
    ['number_pixels', 'remapped', 'treecover2000'], 
    ['numPixelsNoNA', 'numPixelsZeroFC2000', 'meanPctCover2000']            
);

print(tileCounts3);

///////////////////////////////////////////////////////////////////////
//
//  Zonal statistics from GFC and ARD: includes
//    1. No. of camp area buffer boundaties 1-2, 2-3, ...19-20 
//       km from tile centroid that are open in 2001, 2002, ...2012
//
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//
//  Zonal statistics from biome data: includes
//    1. Pct. tile in grasslands, savannahs biome
//    2. Pct. tile in rainforest biome
//    3. Pct. tile in other biomes 
//
///////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////
//
//  Remoteness measure - TBD
//
///////////////////////////////////////////////////////////////////////



