//Refugees and deforestation analysis
//Tabular data export: Group 2

///////////////////////////////////////////////////////////////////////
//
//  Initial data prep
//
///////////////////////////////////////////////////////////////////////

//Read in camp data - this is saved in wide format, with binary indicators
//of whether a camp was open 1999-2016
var camps = ee.FeatureCollection('users/salem043/allcampwidev2');

//Map.addLayer(camps);

//Sub-Saharan Africa administrative district shapefile
var SSA = ee.FeatureCollection('users/salem043/Africa_Districts');


var campFilter = ee.Filter.inList('country', ['Chad',
'CAR', 'Sudan', 'South Sudan', 'Ethiopia',
'Rwanda', 'Burundi', 'DRC', 'Tanzania', 'Rep. Congo',
]);

var filteredArea = camps.filter(campFilter);

var campRegion=camps.filter(campFilter);

///////////////////////////////////////////////////////////////////////
//
//  Create dissolved buffer FC 
//
///////////////////////////////////////////////////////////////////////

//Produce 30 km  buffer around the camps - this the are we are going to study
var bufferPoly = function(feature) {
  return feature.buffer(30000);  //!!Change back to 50k after making sure the border identification works 
};

var buffers = campRegion.map(bufferPoly);

var buffsUnion = buffers.union();

//dissolve and transform to FC so that we can identify each
//tile's buffer ID

var buffsGeoDissolve =buffers.geometry().dissolve();
//print(buffsGeoDissolve, "Dissolve using geometry().dissolve()"); //Multipolygon!
Map.addLayer(buffsGeoDissolve, {}, 'Dissolve using geometry().dissolve()');


var fc = ee.FeatureCollection([
  ee.Feature(buffsGeoDissolve)
]);
//print(fc);

var multiGeomExplodeList = fc.toList(fc.size()).map(function(feature) {
  var geomList = ee.Feature(feature).geometry().geometries();
  var featureList = geomList.map(function(geom) {
    return ee.Feature(ee.Geometry(geom));
  });
  return featureList;
})
.flatten();

var buffDissolveFC = ee.FeatureCollection(multiGeomExplodeList);

///////////////////////////////////////////////////////////////////////
//
//  Tile production - we'll use these tiles to calculate zonal stats.
//  The tiles are the unit of analysis in our regression
//
///////////////////////////////////////////////////////////////////////

//Tiles below are measured in degrees. (Ugh, but I want meters!)
//0.1 degrees is about 11 km at equator. Kept large for training
//Code courtesty of a kind stranger who offered it on Stack Exchange
//!!Need to figure out how to form these tiles in meters
//!!Downscale tiles to finer resolution when scaling up (0.01, about 1 km)
var tiles = tile(buffsUnion, 0.5); 

function tile(region, size_in_degrees) {
  function tile_geometry(geometry) {
    var coords = ee.List(geometry.bounds().coordinates().get(0))
    var min_point = ee.List(coords.get(0))
    var max_point = ee.List(coords.get(2))
  
    function sequence(direction) {
      var start = min_point.get(direction)  
      var stop = ee.Number(max_point.get(direction))
      return ee.List.sequence(start, stop, size_in_degrees)
    }
  
    var tiles = sequence(0).map(function (x) {
      return sequence(1).map(function (y) { 
          return ee.Feature(ee.Geometry.Rectangle([
            [ee.Number(x), ee.Number(y)],
            [
              ee.Number(x).add(size_in_degrees).min(max_point.get(0)),
              ee.Number(y).add(size_in_degrees).min(max_point.get(1))
            ]
        ]).intersection(geometry, 30))
      })
  	}).flatten()
    return ee.FeatureCollection(tiles).filterBounds(geometry)
  }

  function tile_feature_collection(feature_collection) {
    return ee.FeatureCollection(
      feature_collection.iterate(
        function (feature, acc) {
          return ee.FeatureCollection(acc).merge(tile_geometry(ee.Feature(feature).geometry()))
        }, ee.FeatureCollection([]))
    )
  }

  if (region instanceof ee.FeatureCollection)
    return tile_feature_collection(region)
  else if (region instanceof ee.Feature)
    return tile_geometry(region.geometry())
  else if (region instanceof ee.Geometry)
    return tile_geometry(region)
  else
    throw Error(
      'region must be ee.FeatureCollection, ee.Feature, or ee.Geometry. Was ' + region
    )
}

///print(tiles.limit(10), "Baseline tiles");

//Map.addLayer(tiles, {}, "tiles");


///////////////////////////////////////////////////////////////////////
//
//  Get GFCC data for tiles
//
///////////////////////////////////////////////////////////////////////


var gfcc15 = ee.ImageCollection('NASA/MEASURES/GFCC/TC/v3')
      .filter(ee.Filter.date('2015-01-01', '2015-12-31'));
    
var gfcc10 = ee.ImageCollection('NASA/MEASURES/GFCC/TC/v3')
      .filter(ee.Filter.date('2010-01-01', '2010-12-31'));
      
var gfcc05 = ee.ImageCollection('NASA/MEASURES/GFCC/TC/v3')
      .filter(ee.Filter.date('2005-01-01', '2005-12-31'));
      
var gfcc00 = ee.ImageCollection('NASA/MEASURES/GFCC/TC/v3')
      .filter(ee.Filter.date('2000-01-01', '2000-12-31'))
      .select('tree_canopy_cover');


//Use a reducer to convert from an image collection to an image with 1 band
var gfcc2000 = gfcc00.reduce(ee.Reducer.mean());
var gfcc2005 = gfcc05.reduce(ee.Reducer.mean());
var gfcc2010 = gfcc10.reduce(ee.Reducer.mean());
var gfcc2015 = gfcc15.reduce(ee.Reducer.mean());

//Clip GFCC data to SSA
var g00 = gfcc2000.clip(SSA);
var g05 = gfcc2000.clip(SSA);
var g10 = gfcc2000.clip(SSA);
var g15 = gfcc2000.clip(SSA);

//Reproject GFCC data
var proj = ee.Projection("EPSG:4326");

var GFCC2000 = g00.reproject(proj, null, 30);
var GFCC2005 = g05.reproject(proj, null, 30);
var GFCC2010 = g10.reproject(proj, null, 30);
var GFCC2015 = g15.reproject(proj, null, 30);


//Get the number of pixels in each tile

var pixelCounts = tiles.map(function(feature) {
 return feature.set(GFCC2000.reduceRegion({
 reducer: 'count',
 geometry: feature.geometry(),
  }));
});

var counts = pixelCounts.select(["tree_canopy_cover_mean"], ["noPixelsGFCC"]);

//Get the sum of percent forest cover for 2000
var gfccData = counts.map(function(feature) {
 return feature.set(GFCC2000.reduceRegion({
 reducer: 'sum',
 geometry: feature.geometry(),
  }));
});


var gfccfor2000 = gfccData.select(["noPixelsGFCC", "tree_canopy_cover_mean"],
["noPixelsGFCC", "sumCover_2000"]);

//Get the sum of percent forest cover for 2005
var gfccData2 = gfccfor2000.map(function(feature) {
 return feature.set(GFCC2005.reduceRegion({
 reducer: 'sum',
 geometry: feature.geometry(),
  }));
});

var gfccfor2005 = gfccData2.select(["noPixelsGFCC", "sumCover_2000", 
"tree_canopy_cover_mean"],
["noPixelsGFCC", "sumCover_2000", 
"sumCover_2005"]);


//Get the sum of percent forest cover for 2010
var gfccData3 = gfccfor2005.map(function(feature) {
 return feature.set(GFCC2010.reduceRegion({
 reducer: 'sum',
 geometry: feature.geometry(),
  }));
});

var gfccfor2010 = gfccData3.select(["noPixelsGFCC", "sumCover_2000", 
"sumCover_2005", "tree_canopy_cover_mean"],
["noPixelsGFCC", "sumCover_2000", 
"sumCover_2005", "sumCover_2010"]);



//Get the sum of percent forest cover for 2015
var gfccData4 = gfccfor2010.map(function(feature) {
 return feature.set(GFCC2015.reduceRegion({
 reducer: 'sum',
 geometry: feature.geometry(),
  }));
});

var gfccFull = gfccData4.select(["noPixelsGFCC", "sumCover_2000", 
"sumCover_2005", "sumCover_2010", "tree_canopy_cover_mean"],
["noPixelsGFCC", "sumCover_2000", 
"sumCover_2005", "sumCover_2010", "sumCover_2015"]);


//Get number of pixels >=50 pct FC and >=10 pct FC for 2000
  //Create two rasters: one where pixels are 1 if FC>=50, otherwise zero, 
  //and one where pixels are 1 if FC>=10, otherwise zero
  
var gt50in2000 = ee.Image(1)
          .where(GFCC2000.gte(50), 1)
          .where(GFCC2000.lt(50), 0);


//Get the sum of pixels with 50 pct FC or more
var gfccData5 = gfccFull.map(function(feature) {
 return feature.set(gt50in2000.reduceRegion({
 reducer: 'sum',
 geometry: feature.geometry(),
  }));
});

print(gfccData5.limit(4), "GFCC data with 2000 qual count 1");


/////////////////////////////////////////////////////////////////////
//
//Export
//
/////////////////////////////////////////////////////////////////////

///print(pointdata_withbandcounts_12.limit(1)); ///Camp counts by buffers and years
///print(ecosample.limit(1)); ///Biome
///print(remotenessADM.limit(1)); ///Distance to nearest market and ADM
///print(tiles_new.limit(1)); ///GFC number pixels transition to zero FC by year
///print(DataRenamed.limit(1)); //GFC 2000 and within-tile pixel counts
///print(bufferID.limit(1)); //ID of buffer that tile falls in



