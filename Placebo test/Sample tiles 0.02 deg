//Refugees and deforestation analysis
//Placebo sample tiles - 0.01Â°


///////////////////////////////////////////////////////////////////////
//
//  Initial data prep
//
///////////////////////////////////////////////////////////////////////

//Read in camp data - this is saved in wide format, with binary indicators
//of whether a camp was open 1999-2016
var camps = ee.FeatureCollection('users/salem043/campPlaceboWideV2');

Map.addLayer(camps);
print(camps);

var campRegion = camps;


///////////////////////////////////////////////////////////////////////
//
//  Create dissolved buffer FC 
//
///////////////////////////////////////////////////////////////////////

//Produce 30 km  buffer around the camps - this the are we are going to study
var bufferPoly = function(feature) {
  return feature.buffer(30000); 
};

var buffers = campRegion.map(bufferPoly);

var buffsUnion = buffers.union();
//Map.addLayer(buffsUnion);

//dissolve and transform to FC so that we can identify each
//tile's buffer ID

var buffsGeoDissolve =buffers.geometry().dissolve();
//print(buffsGeoDissolve, "Dissolve using geometry().dissolve()"); //Multipolygon!
Map.addLayer(buffsGeoDissolve, {}, 'Dissolve using geometry().dissolve()');


var fc = ee.FeatureCollection([
  ee.Feature(buffsGeoDissolve)
]);
//print(fc);

var multiGeomExplodeList = fc.toList(fc.size()).map(function(feature) {
  var geomList = ee.Feature(feature).geometry().geometries();
  var featureList = geomList.map(function(geom) {
    return ee.Feature(ee.Geometry(geom));
  });
  return featureList;
})
.flatten();

var buffDissolveFC = ee.FeatureCollection(multiGeomExplodeList);

///////////////////////////////////////////////////////////////////////
//
//  Tile production - we'll use these tiles to calculate zonal stats.
//  The tiles are the unit of analysis in our regression
//
///////////////////////////////////////////////////////////////////////

var tiles = tile(buffsUnion, 0.02); 

function tile(region, size_in_degrees) {
  function tile_geometry(geometry) {
    var coords = ee.List(geometry.bounds().coordinates().get(0))
    var min_point = ee.List(coords.get(0))
    var max_point = ee.List(coords.get(2))
  
    function sequence(direction) {
      var start = min_point.get(direction)  
      var stop = ee.Number(max_point.get(direction))
      return ee.List.sequence(start, stop, size_in_degrees)
    }
  
    var tiles = sequence(0).map(function (x) {
      return sequence(1).map(function (y) { 
          return ee.Feature(ee.Geometry.Rectangle([
            [ee.Number(x), ee.Number(y)],
            [
              ee.Number(x).add(size_in_degrees).min(max_point.get(0)),
              ee.Number(y).add(size_in_degrees).min(max_point.get(1))
            ]
        ]).intersection(geometry, 30))
      })
  	}).flatten()
    return ee.FeatureCollection(tiles).filterBounds(geometry)
  }

  function tile_feature_collection(feature_collection) {
    return ee.FeatureCollection(
      feature_collection.iterate(
        function (feature, acc) {
          return ee.FeatureCollection(acc).merge(tile_geometry(ee.Feature(feature).geometry()))
        }, ee.FeatureCollection([]))
    )
  }

  if (region instanceof ee.FeatureCollection)
    return tile_feature_collection(region)
  else if (region instanceof ee.Feature)
    return tile_geometry(region.geometry())
  else if (region instanceof ee.Geometry)
    return tile_geometry(region)
  else
    throw Error(
      'region must be ee.FeatureCollection, ee.Feature, or ee.Geometry. Was ' + region
    )
}

///////////////////////////////////////////////////////////////////////
//
//  Zonal statistics: get tile buffer ID
//
///////////////////////////////////////////////////////////////////////

var buffs2 = buffDissolveFC.select(["system:index"], ["Buffer_ID"]);


var properties = ["Buffer_ID"];

// Define a spatial filter as geometries that intersect.
var spatialFilter = ee.Filter.intersects({
  leftField: '.geo',
  rightField: '.geo'
});

// Join the points and polygons and apply the spatial filter to keep only intersecting ones
var joinAll = ee.Join.saveAll('matched').apply(tiles, buffs2, spatialFilter);

// Since the join adds intersecting polygons to a new property 'matched'
// we need to extract required info from the polygons and copy it to the points
var bufferID = joinAll.map(function(feature){
  var joinedFeat =  ee.List(feature.get('matched'));
  var polygon = ee.Feature(ee.FeatureCollection(joinedFeat).first());
  return ee.Feature(feature.copyProperties(polygon, properties)).select(properties);
});


print('sample extract', bufferID.limit(2));



/////////////////////////////////////////////////////////////////////
//
//Export
//
/////////////////////////////////////////////////////////////////////

Export.table.toDrive({
  collection: bufferID.select(['system:index', "Buffer_ID"],
  ['ID', "Buffer_ID"]),
  fileFormat: 'SHP',
  description: 'PlaceboTilesLULC',
  folder: "deforTilesGEE"
});


