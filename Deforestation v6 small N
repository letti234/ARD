//-------------------------------------------------------------
//-DATA UPLOAD AND CLEANING------------------------------------
//-------------------------------------------------------------

//Hansen Global Forest Change data
var gfc2014 = ee.Image('UMD/hansen/global_forest_change_2015');

//Sub-Saharan Africa administrative district shapefile
var SSA = ee.FeatureCollection('users/salem043/Africa_Districts')

var gfc2014_c = gfc2014.clip(SSA);

//Camp dataset
var camps = ee.FeatureCollection('ft:1DCL5m_EO8kKMis2BWTdzfg-i9uc4uAZ2xNLQuhf7');
Map.addLayer(camps, {color: 'red'}, 'camps');

//50 km  buffer around camps
var bufferPoly = function(feature) {
  return feature.buffer(50000);   
};

var buffers = camps.map(bufferPoly);
//Map.addLayer(buffers, {color: 'yellow'}, 'buffers');

//Randomly select 1 million pixels within the buffer areas (you can reduce the N to test the code)
var points = ee.FeatureCollection.randomPoints(buffers, 100);

//print("Initial draw of points", points);
//Map.addLayer(points, {color: 'blue'}, 'points');

//-------------------------------------------------------------
//MEASURE DISTANCE BETWEEN RANDOM POINTS AND NEAREST CAMP -----
//-------------------------------------------------------------

//These commands identify the "nearest neighbor" camps and then determine
//the closest one and the distace between pixel and camps

var spatialFilter = ee.Filter.withinDistance({
  distance: 50000,
  leftField: '.geo',
  rightField: '.geo',
  maxError: 10
});

// Join the points
var joined = ee.Join.saveAll({
  matchesKey: 'neighbors', 
  measureKey: 'distance',
  ordering: 'distance'
}).apply({
  primary: points, 
  secondary: camps, 
  condition: spatialFilter
});

// Get distance to nearest point.
var withNearestDist = joined.map(function(f) {
  var nearestDist = ee.Feature(ee.List(f.get('neighbors')).get(0))
      .get('distance');
  return f.set('nearestDist', nearestDist);
});


// Add the id number of the nearest camp (for later data merging)
var pointdata = withNearestDist.map(function(f) {
  var nearestCamp = ee.Feature(ee.List(f.get('neighbors')).get(0))
      .get('campid');
  return f.set('campid', nearestCamp);
});


//print('Feature with camp id and distance', pointdata);



//-------------------------------------------------------------
//OBTAIN COUNT OF NUMBER OF CAMPS 5, 10, 15, 20 KM AWAY--------
//-------------------------------------------------------------

//These functions count how many camps are within a 5, 10, 15, and 
//20 km buffer from each pixel, respectively

var pointdata_withbandcounts = pointdata.map(function(pt) {
  var neighs = ee.List(pt.get('neighbors'));
  var filt = ee.Filter.lt('distance', 20000);
  pt=pt.set('neighsSize20', neighs.filter(filt).size());
  filt = ee.Filter.lt('distance', 15000);
  pt=pt.set('neighsSize15', neighs.filter(filt).size());
  filt = ee.Filter.lt('distance', 10000);
  pt=pt.set('neighsSize10', neighs.filter(filt).size());
  filt = ee.Filter.lt('distance', 5000);
  pt=pt.set('neighsSize5', neighs.filter(filt).size());
  return(pt);
});

//print("with band counts", pointdata_withbandcounts);


//-------------------------------------------------------------
//EXTRACTING INFORMATION FROM THE SSA SHAPEFILE AND HANSEN DATA
//-------------------------------------------------------------

//The SSA shapefile includes information on country, district, and
//sub-district. These functions extract that information such that
//each pixel's admin. data is identified

//Specify the properties that I want to copy from the SSA shapefile
var properties = ["ADM0","ADM1", "ADM2", "campid"];

// Define a spatial filter as geometries that intersect.
var spatialFilter = ee.Filter.intersects({
  leftField: '.geo',
  rightField: '.geo'
});

// Join the points and polygons and apply the spatial filter to keep only intersecting ones
var joinAll = ee.Join.saveAll('matched').apply(pointdata_withbandcounts, SSA, spatialFilter);

// Since the join adds intersecting polygons to a new property 'matched'
// we need to extract required info from the polygons and copy it to the points
var featuresWithProp = joinAll.map(function(feature){
  var joinedFeat =  ee.List(feature.get('matched'));
  var polygon = ee.Feature(ee.FeatureCollection(joinedFeat).first());
  return ee.Feature(feature.copyProperties(polygon, properties)).select(properties);
});

//print('District data for sample points', featuresWithProp);


//-------------------------------------------------------------
//JOIN HANSEN AND DISTRICT DATA TO CAMP DATA-------------------
//-------------------------------------------------------------

//Adding the deforestation data to our data frame

var filter = ee.Filter.equals({
  leftField: 'system:index',
  rightField: 'system:index'
});

// Create the join.
var simpleJoin = ee.Join.inner();

var simpleJoined = simpleJoin.apply(featuresWithProp, pointdata_withbandcounts, filter);

var newjoin=simpleJoined.map(function(pair) {
  var f1 = ee.Feature(pair.get('primary'));
  var f2 = ee.Feature(pair.get('secondary'));
  return f1.set(f2.toDictionary());
});

//print("Sample points camp and district data", newjoin);


//This function will fill in the characteristics of the GFC /////////////////////////////////////////////

//Specify the properties that I want to copy from the SSA shapefile
var prop2 = ["ADM0","ADM1", "ADM2", "campid", "nearestDist", "neighsSize5", "neighsSize10", "neighsSize15", "neighsSize20"];

var sampledPoints = gfc2014.sampleRegions({
 collection:newjoin,
 properties:prop2,
 geometries:true
});

//print("Final feature collection", sampledPoints);


//-------------------------------------------------------------
//CREATE LEAST COST PATH VARIABLE, ADD TO DATA-----------------
//-------------------------------------------------------------

//Least cost path is an alternative distance measure that accounts
//for topography.
var sources = ee.Image().toByte().paint(camps, 1);

sources = sources.updateMask(sources);

// The cost data is generated from classes in ESA/GLOBCOVER.
var cover = ee.Image('ESA/GLOBCOVER_L4_200901_200912_V2_3').select(0);

// Classes 60, 80, 110, 140 have cost 1.
// Classes 40, 90, 120, 130, 170 have cost 2.
// Classes 50, 70, 150, 160 have cost 3.
var cost =
  cover.eq(60).or(cover.eq(80)).or(cover.eq(110)).or(cover.eq(140))
      .multiply(1).add(
  cover.eq(40).or(cover.eq(90)).or(cover.eq(120)).or(cover.eq(130))
    .or(cover.eq(170))
      .multiply(2).add(
  cover.eq(50).or(cover.eq(70)).or(cover.eq(150)).or(cover.eq(160))
      .multiply(3)));

// Compute the cumulative cost to traverse the land cover.
var cumulativeCost = cost.cumulativeCost({
  source: sources,
  maxDistance: 50 * 1000 // 50 kilometers
});

// Display the results
//Map.addLayer(cumulativeCost, {min: 0, max: 5e4}, 'accumulated cost');


var prop2 = ["ADM0", "ADM1", "ADM2", "campid", "nearestDist", "neighsSize5", "neighsSize10", "neighsSize15", "neighsSize20", "lossyear", "treecover2000"];

var sampledPoints2 = cumulativeCost.sampleRegions({
 collection:sampledPoints,
 properties:prop2,
 geometries:true
});

//print("Final sample with least cost path", sampledPoints2)

//-------------------------------------------------------------
//EXPORT DATA IN CHUNKS----------------------------------------
//-------------------------------------------------------------



//Current chunk size is 100,000. Change "chunk" below if need 
//to make smaller.
var chunk = 50000;
var collectionSize = 1000000;
for (var i = 0; i<collectionSize;i=i+chunk){
  var subset = ee.FeatureCollection(sampledPoints2.toList(chunk, i));
  Export.table.toDrive(subset, "Chunk_", "Deforestation");
}



