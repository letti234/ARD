//REFUGEE CAMPS AND DEFORESTATION V 7
//COLETTE SALEMI
//23 NOV 2019

//Trainer version,N=20


//-------------------------------------------------------------
// 
//DATA UPLOAD AND CLEANING
//  
//-------------------------------------------------------------

//Hansen Global Forest Change data
var gfc2014 = ee.Image('UMD/hansen/global_forest_change_2015');

//Sub-Saharan Africa administrative district shapefile
var SSA = ee.FeatureCollection('users/salem043/Africa_Districts')

var gfc2014_c = gfc2014.clip(SSA);

//Camp dataset
var camps = ee.FeatureCollection('ft:1DCL5m_EO8kKMis2BWTdzfg-i9uc4uAZ2xNLQuhf7');
Map.addLayer(camps, {color: 'red'}, 'camps');

//50 km  buffer around camps
var bufferPoly = function(feature) {
  return feature.buffer(50000);   
};

var buffers = camps.map(bufferPoly);
//Map.addLayer(buffers, {color: 'yellow'}, 'buffers');

//Randomly select 100 pixels
var points = ee.FeatureCollection.randomPoints(buffers, 20);

//print("Initial draw of points", points);
//Map.addLayer(points, {color: 'blue'}, 'points');


//-------------------------------------------------------------
//CREATE LEAST COST PATH VARIABLE, ADD TO DATA-----------------
//-------------------------------------------------------------

//Distance set very high here due to large size of grids during testing
var spatialFilter = ee.Filter.withinDistance({
  distance: 500000,
  leftField: '.geo',
  rightField: '.geo',
});

//Least cost path is an alternative distance measure that accounts
//for topography.
var sources = ee.Image().toByte().paint(camps, 1);

sources = sources.updateMask(sources);

// The cost data is generated from classes in ESA/GLOBCOVER.
var cover = ee.Image('ESA/GLOBCOVER_L4_200901_200912_V2_3').select(0);

// Classes 60, 80, 110, 140 have cost 1.
// Classes 40, 90, 120, 130, 170 have cost 2.
// Classes 50, 70, 150, 160 have cost 3.
var cost =
  cover.eq(60).or(cover.eq(80)).or(cover.eq(110)).or(cover.eq(140))
      .multiply(1).add(
  cover.eq(40).or(cover.eq(90)).or(cover.eq(120)).or(cover.eq(130))
    .or(cover.eq(170))
      .multiply(2).add(
  cover.eq(50).or(cover.eq(70)).or(cover.eq(150)).or(cover.eq(160))
      .multiply(3)));

// Compute the cumulative cost to traverse the land cover.
var cumulativeCost = cost.cumulativeCost({
  source: sources,
  maxDistance: 50 * 1000 // 50 kilometers
});

// Display the results
//Map.addLayer(cumulativeCost, {min: 0, max: 5e4}, 'accumulated cost');


var joined_leastcost = ee.Join.saveAll({
  matchesKey: 'neighbors', 
  measureKey: 'distance',
  ordering: 'cumulativeCost'
}).apply({
  primary: points, 
  secondary: camps, 
  condition: spatialFilter
});

// Minimize the cost path to find "nearest" urban grid

var nearest_UR_LC = joined_leastcost.map(function(f) {
  var nearestDist_LC = ee.Feature(ee.List(f.get('neighbors')).get(0))
      .get('distance');
  return f.set('nearestDist_LC', nearestDist_LC);
});

print("Step 1 of LC", nearest_UR_LC);


// Add the ID number of the nearest camp 
var nearest_ID_LC = nearest_UR_LC.map(function(f) {
  var nearestcamp = ee.Feature(ee.List(f.get('neighbors')).get(0))
      .get('campid');
  return f.set('campid_lc', nearestcamp);
});

print('point data with nearest camp (lc)', nearest_ID_LC);



//-------------------------------------------------------------
//MEASURE DISTANCE BETWEEN RANDOM POINTS AND NEAREST CAMP -----
//-------------------------------------------------------------

//These commands identify the "nearest neighbor" camps and then determine
//the closest one and the distace between pixel and camps

var spatialFilter = ee.Filter.withinDistance({
  distance: 50000,
  leftField: '.geo',
  rightField: '.geo',
  maxError: 10
});

// Join the points
var joined = ee.Join.saveAll({
  matchesKey: 'neighbors', 
  measureKey: 'distance',
  ordering: 'distance'
}).apply({
  primary: points, 
  secondary: camps, 
  condition: spatialFilter
});

// Get distance to nearest point.
var withNearestDist = joined.map(function(f) {
  var nearestDist = ee.Feature(ee.List(f.get('neighbors')).get(0))
      .get('distance');
  return f.set('nearestDist', nearestDist);
});

print('DF with nearest camp', withNearestDist);

// Add the id number of the nearest camp (for later data merging)
var pointdata = withNearestDist.map(function(f) {
  var nearestCamp = ee.Feature(ee.List(f.get('neighbors')).get(0))
      .get('campid');
  return f.set('campid', nearestCamp);
});

print('DF with nearest camp ID', withNearestDist);

//print('Feature with camp id and distance', pointdata);



//-------------------------------------------------------------
//OBTAIN COUNT OF NUMBER OF CAMPS 5, 10, 15, 20 KM AWAY--------
//-------------------------------------------------------------

//These functions count how many camps are within a 5, 10, 15, and 
//20 km buffer from each pixel, respectively

var pointdata_withbandcounts = pointdata.map(function(pt) {
  var neighs = ee.List(pt.get('neighbors'));
  var filt = ee.Filter.lt('distance', 20000);
  pt=pt.set('neighsSize20', neighs.filter(filt).size());
  filt = ee.Filter.lt('distance', 15000);
  pt=pt.set('neighsSize15', neighs.filter(filt).size());
  filt = ee.Filter.lt('distance', 10000);
  pt=pt.set('neighsSize10', neighs.filter(filt).size());
  filt = ee.Filter.lt('distance', 5000);
  pt=pt.set('neighsSize5', neighs.filter(filt).size());
  return(pt);
});


print('linear data', pointdata_withbandcounts);


//-------------------------------------------------------------
//MERGE LEAST COST PATH AND LINEAR MEASURE DATAFRAMES----------
//-------------------------------------------------------------




