

var lat_start = 40;
var lat_end = 43;
var lon_start = 62; 
var lon_end = 67;


var num_cells = 10;
var lon_edge = (lon_end-lon_start)/Math.sqrt(num_cells);
var lat_edge = (lat_end-lat_start)/Math.sqrt(num_cells);
// 3) Create the grid
var polys = [];
var polys_line = [];
var cell_id = 0;
for (var lon = lon_start; lon < lon_end; lon += lon_edge) {
  var x1 = lon;
  var x2 = lon + lon_edge;
  for (var lat = lat_start; lat < lat_end; lat += lat_edge) {
    cell_id = cell_id + 1;
    var y1 = lat;
    var y2 = lat + lat_edge;

    polys.push(ee.Feature(ee.Geometry.Rectangle(x1, y1, x2, y2), {label: cell_id}));
  }
}

var grid = ee.FeatureCollection(polys)
Map.addLayer(grid);


var urbangrid = grid.filter(ee.Filter.gt('system:index', "5"));
print('urban grids', urbangrid);


//If we treated the urban grids as a homogeneous source
var geometry = urbangrid;

// Create a source image where the geometry is 1, everything else is 0.
var sources = ee.Image().toByte().paint(geometry, 1);

// Mask the sources image with itself.
sources = sources.updateMask(sources);

// The cost data is generated from classes in ESA/GLOBCOVER.
var cover = ee.Image('ESA/GLOBCOVER_L4_200901_200912_V2_3').select(0);

var cost =
  cover.eq(60).or(cover.eq(80)).or(cover.eq(110)).or(cover.eq(140))
      .multiply(1).add(
  cover.eq(40).or(cover.eq(90)).or(cover.eq(120)).or(cover.eq(130))
    .or(cover.eq(170))
      .multiply(2).add(
  cover.eq(50).or(cover.eq(70)).or(cover.eq(150)).or(cover.eq(160))
      .multiply(3)));

// Compute the cumulative cost to traverse the land cover.
var cumulativeCost = cost.cumulativeCost({
  source: sources,
  maxDistance: 200 * 1000 
});

// Display the results
Map.addLayer(cumulativeCost, {min: 0, max: 5e4}, 'accumulated cost');
Map.addLayer(geometry, {color: 'FF0000'}, 'source geometry'); 
